<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <link rel="icon" type="image/png" href="/static/favicon-96x96.png" sizes="96x96" />
    <link rel="icon" type="image/svg+xml" href="/static/favicon.svg" />
    <link rel="shortcut icon" href="/static/favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180" href="/static/apple-touch-icon.png" />
    <link rel="manifest" href="/static/site.webmanifest" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Imaginary Gallery</title>
    <link rel="stylesheet" href="/static/css/styles.css" />
    {% include "components/liked_image_glow.html" %}
    <style>
      /* Firefox scroll snap fix */
      .snap-container {
        scroll-snap-type: y mandatory;
        -webkit-overflow-scrolling: touch;
        height: 100vh;
        overflow-y: auto;
        scrollbar-width: none; /* Firefox */
        -ms-overflow-style: none; /* IE and Edge */
      }
      .snap-container::-webkit-scrollbar {
        display: none; /* Chrome, Safari, Opera */
      }
      .snap-item {
        scroll-snap-align: start;
        scroll-snap-stop: always;
        height: 100vh;
        min-height: 100vh;
      }
    </style>
  </head>

  <body class="bg-zinc-900 text-white">
    <div class="snap-container">
      {% for item in items %}
      <div class="flex items-center justify-center snap-item" data-image-id="{{item.id}}">
        <div class="flex flex-col items-center">
          <h1 class="mb-4 font-medium text-xl dark:text-slate-100"> {{ item.title }} </h1>
          <div class="w-full sm:w-4/5 md:w-3/5 lg:w-2/5 sm:rounded-md image-container" data-image-id="{{item.id}}">
            <img class="object-contain sm:rounded-md" src="/img/{{item.id}}.webp" alt=""/>
          </div>
        </div>
      </div>
      {% endfor %}
    </div>
    
    <div class="fixed inset-0 flex items-center justify-center pointer-events-none z-50">
      {% include "components/like_button.html" %}
    </div>
    
    <div class="fixed bottom-8 left-1/2 transform -translate-x-1/2 pointer-events-none z-40 transition-opacity duration-300" id="scroll-hint-arrow">
      {% include "components/down_arrow.html" %}
    </div>

    <script>
      let lastItemId = null;
      let firstItemId = null;
      let isLoadingBottom = false;
      let isLoadingTop = false;
      let hasMoreBottom = true;
      let hasMoreTop = true;

      const bottomObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting && !isLoadingBottom && hasMoreBottom) {
            loadMoreItemsBottom();
          }
        });
      }, {
        root: null,
        rootMargin: '100px',
        threshold: 0.1
      });

      const topObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting && !isLoadingTop && hasMoreTop) {
            loadMoreItemsTop();
          }
        });
      }, {
        root: null,
        rootMargin: '100px',
        threshold: 0.1
      });

      async function loadMoreItemsBottom() {
        if (isLoadingBottom || !hasMoreBottom) return;
        isLoadingBottom = true;

        try {
          // Get the last item's ID
          const items = document.querySelectorAll('.snap-item');
          if (lastItemId === null && items.length > 0) {
            lastItemId = items[items.length - 1].getAttribute('data-image-id');
          }
          
          const response = await fetch(`/api/before/${lastItemId}`);
          const data = await response.json();
          
          if (data.results && data.results.length > 0) {
            appendItems(data.results);
            // Update lastItemId to the last item in the new results
            lastItemId = data.results[data.results.length - 1].id;
            
            // If we got fewer items than expected, we might be at the end
            if (data.results.length < 5) {
              hasMoreBottom = false;
            }
            
            // Observe the new second to last item
            const updatedItems = document.querySelectorAll('.snap-item');
            if (updatedItems.length >= 2) {
              bottomObserver.disconnect();
              const secondToLastItem = updatedItems[updatedItems.length - 2];
              bottomObserver.observe(secondToLastItem);
            }
          } else {
            hasMoreBottom = false;
          }
        } catch (error) {
          console.error('Failed to load more items at bottom:', error);
        } finally {
          isLoadingBottom = false;
        }
      }

      async function loadMoreItemsTop() {
        if (isLoadingTop || !hasMoreTop) return;
        isLoadingTop = true;

        try {
          // Get the first item's ID
          const items = document.querySelectorAll('.snap-item');
          if (firstItemId === null && items.length > 0) {
            firstItemId = items[0].getAttribute('data-image-id');
          }
          
          const response = await fetch(`/api/after/${firstItemId}`);
          const data = await response.json();
          
          if (data.results && data.results.length > 0) {
            prependItems(data.results);
            firstItemId = data.results[data.results.length - 1].id;
            
            if (data.results.length < 5) {
              hasMoreTop = false;
            }
            
            // Re-observe the second item from top
            const updatedItems = document.querySelectorAll('.snap-item');
            if (updatedItems.length >= 2) {
              topObserver.disconnect();
              const secondItem = updatedItems[1];
              topObserver.observe(secondItem);
            }
          } else {
            hasMoreTop = false;
          }
        } catch (error) {
          console.error('Failed to load more items at top:', error);
        } finally {
          isLoadingTop = false;
        }
      }

      function appendItems(items) {
        const container = document.querySelector('.snap-container');
        
        items.forEach(item => {
          const itemDiv = document.createElement('div');
          itemDiv.className = 'flex items-center justify-center snap-item';
          itemDiv.setAttribute('data-image-id', item.id);
          itemDiv.innerHTML = `
            <div class="flex flex-col items-center">
              <h1 class="mb-4 font-medium text-xl dark:text-slate-100">${item.title}</h1>
              <div class="w-full sm:w-4/5 md:w-3/5 lg:w-2/5 sm:rounded-md image-container" data-image-id="${item.id}">
                <img class="object-contain sm:rounded-md" src="/img/${item.id}.webp" alt=""/>
              </div>
            </div>
          `;
          container.appendChild(itemDiv);
        });
      }

      function prependItems(items) {
        const container = document.querySelector('.snap-container');
        const scrollHeightBefore = container.scrollHeight;
        const scrollTopBefore = container.scrollTop;
        
        for (let i = 0; i < items.length; i++) {
          const item = items[i];
          const itemDiv = document.createElement('div');
          itemDiv.className = 'flex items-center justify-center snap-item';
          itemDiv.setAttribute('data-image-id', item.id);
          itemDiv.innerHTML = `
            <div class="flex flex-col items-center">
              <h1 class="mb-4 font-medium text-xl dark:text-slate-100">${item.title}</h1>
              <div class="w-full sm:w-4/5 md:w-3/5 lg:w-2/5 sm:rounded-md image-container" data-image-id="${item.id}">
                <img class="object-contain sm:rounded-md" src="/img/${item.id}.webp" alt=""/>
              </div>
            </div>
          `;
          container.insertBefore(itemDiv, container.firstChild);
        }
        
        // Maintain scroll position after prepending
        const scrollHeightAfter = container.scrollHeight;
        const scrollHeightDiff = scrollHeightAfter - scrollHeightBefore;
        container.scrollTop = scrollTopBefore + scrollHeightDiff;
      }

      // Like button functionality
      let currentVisibleImage = null;
      let currentImageId = null;
      let likedImages = new Set();
      let touchTime = 0;
      let hasUserScrolled = false;
      
      function loadLikedImages() {
        try {
          const saved = localStorage.getItem('likedImages');
          if (saved) {
            likedImages = new Set(JSON.parse(saved));
          }
        } catch (e) {
          console.error('Failed to load liked images:', e);
          likedImages = new Set();
        }
      }
      
      function saveLikedImages() {
        try {
          localStorage.setItem('likedImages', JSON.stringify([...likedImages]));
        } catch (e) {
          console.error('Failed to save liked images:', e);
        }
      }
      
      function updateLikeListener() {
        if (currentVisibleImage) {
          currentVisibleImage.removeEventListener('dblclick', handleLike);
          currentVisibleImage.removeEventListener('touchend', handleTouch);
        }
        
        const snapItems = document.querySelectorAll('.snap-item');
        const container = document.querySelector('.snap-container');
        const containerRect = container.getBoundingClientRect();
        
        snapItems.forEach(item => {
          const itemRect = item.getBoundingClientRect();
          // Check if item is in viewport (more than 50% visible)
          if (itemRect.top < containerRect.height * 0.5 && itemRect.bottom > containerRect.height * 0.5) {
            currentVisibleImage = item.querySelector('img');
            const newImageId = item.getAttribute('data-image-id');
            
            if (newImageId !== currentImageId) {
              currentImageId = newImageId;
              if (hasUserScrolled) {
                updateURLWithImageId(currentImageId);
              }
            }
            
            if (currentVisibleImage) {
              currentVisibleImage.addEventListener('dblclick', handleLike);
              currentVisibleImage.addEventListener('touchend', handleTouch);
              updateHeartButtonState();
            }
          }
        });
      }
      
      function updateURLWithImageId(imageId) {
        const url = new URL(window.location);
        url.searchParams.set('id', imageId);
        window.history.replaceState({}, '', url);
      }
      
      function updateHeartButtonState() {
        const likeButton = document.querySelector('.like-button');
        if (likedImages.has(currentImageId)) {
          likeButton.classList.add('liked');
        } else {
          likeButton.classList.remove('liked');
        }
        updateImageGlowState();
      }
      
      function updateImageGlowState() {
        const imageContainers = document.querySelectorAll('.image-container');
        imageContainers.forEach(container => {
          const imageId = container.getAttribute('data-image-id');
          if (likedImages.has(imageId)) {
            if (!container.classList.contains('image-glow-container')) {
              container.classList.add('image-glow-container');
              
              // Create animated border elements
              const glowBox = document.createElement('div');
              glowBox.className = 'animated-border-box-glow';
              
              const borderBox = document.createElement('div');
              borderBox.className = 'animated-border-box';
              
              container.appendChild(glowBox);
              container.appendChild(borderBox);
              
              // Trigger fade in after elements are added
              setTimeout(() => {
                container.classList.add('glow-active');
              }, 10);
            } else {
              container.classList.add('glow-active');
            }
          } else {
            if (container.classList.contains('image-glow-container')) {
              container.classList.remove('glow-active');
              
              // Remove elements after fade out completes
              setTimeout(() => {
                container.classList.remove('image-glow-container');
                const glowBox = container.querySelector('.animated-border-box-glow');
                const borderBox = container.querySelector('.animated-border-box');
                if (glowBox) glowBox.remove();
                if (borderBox) borderBox.remove();
              }, 1200); // Match transition duration
            }
          }
        });
      }
      
      function toggleLike() {
        if (!currentImageId) return;
        
        const likeButton = document.querySelector('.like-button');
        const wasLiked = likedImages.has(currentImageId);
        
        if (wasLiked) {
          likedImages.delete(currentImageId);
          likeButton.classList.remove('liked');
        } else {
          likedImages.add(currentImageId);
          likeButton.classList.add('liked');
          
          // Spawn independent fireworks
          const fireworksContainer = document.createElement('div');
          fireworksContainer.style.transform = 'scale(0.4)';
          fireworksContainer.style.position = 'absolute';
          fireworksContainer.style.pointerEvents = 'none';
          
          const fireworks = document.createElement('div');
          fireworks.className = 'heart-fireworks-effect';
          fireworksContainer.appendChild(fireworks);
          likeButton.appendChild(fireworksContainer);
          
          // Remove fireworks after animation completes
          setTimeout(() => {
            if (fireworksContainer.parentNode) {
              fireworksContainer.parentNode.removeChild(fireworksContainer);
            }
          }, 6250);
        }
        
        saveLikedImages();
        updateImageGlowState();
        
        if (wasLiked) {
          likeButton.classList.add('animating', 'unliking');
        } else {
          likeButton.classList.add('animating', 'liking');
        }
        
        setTimeout(() => {
          likeButton.classList.remove('animating', 'liking', 'unliking');
        }, 800);
      }
      
      function handleLike(e) {
        e.preventDefault();
        toggleLike();
      }
      
      function handleTouch(e) {
        e.preventDefault();
        const currentTime = new Date().getTime();
        const tapLength = currentTime - touchTime;
        if (tapLength < 500 && tapLength > 0) {
          toggleLike();
        }
        touchTime = currentTime;
      }
      
      function updateScrollHintArrow() {
        const container = document.querySelector('.snap-container');
        const arrow = document.getElementById('scroll-hint-arrow');
        
        // Hide arrow when scrolled past the first viewport (100vh)
        if (container.scrollTop > window.innerHeight * 0.5) {
          arrow.style.opacity = '0';
        } else {
          arrow.style.opacity = '1';
        }
      }
      
      document.querySelector('.snap-container').addEventListener('scroll', () => {
        hasUserScrolled = true;
        updateLikeListener();
      });
      document.querySelector('.snap-container').addEventListener('scroll', updateScrollHintArrow);

      // Initialize observers and handle scroll position
      document.addEventListener('DOMContentLoaded', async () => {
        loadLikedImages();
        
        const container = document.querySelector('.snap-container');
        const items = document.querySelectorAll('.snap-item');
        
        // Reset scroll to top to show the first item (which is the item from the URL if refreshed)
        container.scrollTop = 0;
        
        if (items.length > 0) {
          // Initialize IDs for pagination
          firstItemId = items[0].getAttribute('data-image-id');
          lastItemId = items[items.length - 1].getAttribute('data-image-id');
          
          // Check if we have an ID in the URL (meaning we should check for items above)
          const urlParams = new URLSearchParams(window.location.search);
          const urlId = urlParams.get('id');
          
          if (urlId) {
            // We have an ID param, so there might be items above - try to load them
            try {
              const response = await fetch(`/api/after/${firstItemId}`);
              const data = await response.json();
              
              if (data.results && data.results.length > 0) {
                hasMoreTop = true;
                
                prependItems(data.results);
                firstItemId = data.results[data.results.length - 1].id;
                
                if (data.results.length < 5) {
                  hasMoreTop = false;
                }
              } else {
                hasMoreTop = false;
              }
            } catch (error) {
              console.error('Failed to check for items above:', error);
              hasMoreTop = false;
            }
          } else {
            hasMoreTop = false;
          }
          
          // Re-query items after potential prepending
          const updatedItems = document.querySelectorAll('.snap-item');
          
          // Set up bottom observer (for scrolling down)
          if (updatedItems.length >= 2) {
            const secondToLastItem = updatedItems[updatedItems.length - 2];
            bottomObserver.observe(secondToLastItem);
          }
          
          // Set up top observer (for scrolling up) 
          // Only observe if there's more than one item and we might have more above
          if (updatedItems.length >= 2 && hasMoreTop) {
            const secondItem = updatedItems[1];
            topObserver.observe(secondItem);
          }
        }
        
        updateLikeListener();
        updateImageGlowState();
      });
    </script>
  </body>
</html>
